package ch.uzh.ifi.ce.cabne.execution;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.NavigableMap;
import java.util.Scanner;
import java.util.TreeMap;

import ch.uzh.ifi.ce.cabne.BR.BRCalculator;
import ch.uzh.ifi.ce.cabne.algorithm.BNESolverContext;
import ch.uzh.ifi.ce.cabne.domains.Mechanism;
import ch.uzh.ifi.ce.cabne.domains.LLG.AusubelBaranovLLGSampler;
import ch.uzh.ifi.ce.cabne.domains.LLG.NearestBid;
import ch.uzh.ifi.ce.cabne.domains.LLG.Proportional;
import ch.uzh.ifi.ce.cabne.domains.LLG.Proxy;
import ch.uzh.ifi.ce.cabne.domains.LLG.Quadratic;
import ch.uzh.ifi.ce.cabne.integration.MCIntegrator;
import ch.uzh.ifi.ce.cabne.strategy.Strategy;
import ch.uzh.ifi.ce.cabne.strategy.UnivariatePWLStrategy;


public class LLGExtrinsicBNEpass2 extends LLGExperimentBase {
	
	
	public static void main(String[] args) throws InterruptedException, IOException {
		// Extract arguments.
		// this entry point is called with the name of the rule, alpha, gamma, etc.
		// It is meant to be called directly. Another entrypoint called SbatchEntryPoint can be called with
		// a single int as argument.
		String mechanismName = args[0];
		double alpha = Double.parseDouble(args[1]);
		double gamma = Double.parseDouble(args[2]);
		String algorithmName = args[3];
		int runIndex = Integer.parseInt(args[4]);
		String configfile = args[5];
		Path outputfolder = Paths.get(args[6]);
		Path pass1Resultfolder = Paths.get(args[7]);
		
		String basename = String.format("%s-%2.1f-%2.1f-%s-run%03d", mechanismName, alpha, gamma, algorithmName, runIndex);
		Path inputFile = pass1Resultfolder.resolve(basename);
		Path outputFile = outputfolder.resolve(basename);

		Mechanism<Double, Double> mechanism;
		switch (mechanismName) {
			case "proportional":
				mechanism = new Proportional();
				break;
			case "quadratic":
				mechanism = new Quadratic();
				break;
			case "proxy":
				mechanism = new Proxy();
				break;
			case "nearestbid":
				mechanism = new NearestBid();
				break;
			default:
				throw new RuntimeException("Unknown rule");
		}
				
		// create context
		BNESolverContext<Double, Double> context = new BNESolverContext<>();
		context.parseConfig(configfile);	
		context.activateConfig("verificationstep");
		context.setMechanism(mechanism);
		context.setSampler(new AusubelBaranovLLGSampler(alpha, gamma, context));
		context.setIntegrator(new MCIntegrator<Double, Double>(context)); // note that this is not used when using statistical tests
		
		// read general algorithm settings from config
		
		
		// NOTE: algorithmName is the algorithm we are analyzing, not the one we are running!
		// The algorithm we want to actually use is the most advanced version without adaptive CPs
		// We offset the runIndex because we want the verification to be uncorrelated to the original run.
		configureAlgorithm("5pattern", context, seedFromIndex(runIndex + 50));
		
		
		// -----------------------------------------------------------------------------------
		// finished setup, now comes the main loop
		// -----------------------------------------------------------------------------------
		
		long cumulativeComputationTime = 0;
		// String builder that assembles the output.
		StringBuilder builder = new StringBuilder("Iter    absolute eps  time(ms)  total time(ms)\n");
        
        // Process the file generated by pass1 one line at a time
    	Scanner filescanner = new Scanner(inputFile);
        while (filescanner.hasNext()) {            
        	Scanner linescanner = new Scanner(filescanner.nextLine());
            int iteration = linescanner.nextInt();
            if (iteration == -1) {
            	// this is the analytical BNE, which means that we have gone through the entire file 
            	// without finding a converged strategy
            	break;
            }
            
            linescanner.next(); // iteration type, e.g. "INNER"
            long computationTime = linescanner.nextLong();
            cumulativeComputationTime += computationTime;
            linescanner.next(); // epsilon
            linescanner.next(); // "#" i.e. a literal hash
            NavigableMap<Double, Double> intervalMap = new TreeMap<>();
            while (linescanner.hasNext()) {
            	double value = linescanner.nextDouble();
            	double bid = linescanner.nextDouble();
            	intervalMap.put(value, bid);
            }
            linescanner.close();
            Strategy<Double, Double> currentStrategies = new UnivariatePWLStrategy(intervalMap);
            
            
//            // Skip first couple of iterations
//            if (iteration < 3) {
//            	continue;
//            }
            
            System.out.println("Starting Iteration " + iteration);
            
            // Get more precise best response, which the algorithm itself doesn't know

    		ArrayList<Strategy<Double, Double>> strats = new ArrayList<>(3);
    		strats.add(0, currentStrategies);
    		strats.add(1, currentStrategies);
    		strats.add(2, UnivariatePWLStrategy.makeTruthful(0.0, 2.0));
    		
			context.advanceRngs();
			
			BRCalculator.Result<Double, Double> result = context.brc.computeBR(0, strats);
			
			builder.append(String.format(" %3d   %12.9f     %6d          %6d\n", 
										 iteration, 
										 result.epsilonAbs, 
										 computationTime,
										 cumulativeComputationTime));
            
            // See if we are converged
            if (result.epsilonAbs <= Double.parseDouble(context.config.get("epsilon"))) {
            	break;
            }

        }
        filescanner.close();
        
		Files.write(outputFile, builder.toString().getBytes(), 
				    StandardOpenOption.CREATE, 
				    StandardOpenOption.WRITE, 
				    StandardOpenOption.TRUNCATE_EXISTING);
	}

}
